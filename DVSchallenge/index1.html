<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
  <script
    src="https://code.jquery.com/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
    crossorigin="anonymous"></script>
  <script src="../vendor/semantic/semantic.min.js"></script>
  <link rel="stylesheet" type="text/css" href="../vendor/semantic/semantic.min.css">
  <style>
    @font-face {
        font-family: 'ProximaNova';
        src: local('ProximaNova'), url("../vendor/fonts/proximanova-regular.otf") format("opentype");
    }
    @font-face {
        font-family: 'ProximaNova';
        font-weight: 'light';
        src: local('ProximaNova'), url("../vendor/fonts/proximanova-light.otf") format("opentype");
    }
    @font-face {
        font-family: 'ProximaNova';
        font-weight: 'semibold';
        src: local('ProximaNova'), url("../vendor/fonts/proximanova-semibold.otf") format("opentype");
    }
    @font-face {
        font-family: 'ProximaNova';
        font-weight: bold;
        src: local('ProximaNova'), url("../vendor/fonts/proximanova-bold.otf") format("opentype");
    }
    h1, h2, h3, h4, p, text, span, div {
      font-family: 'ProximaNova', sans-serif;
      padding: 5px;
      margin: 0px;
      border: 0px;
      color: #11210D;
    }
    text {
      font-size: 1.2em;
    }
    h3 {
      float: left;
    }
    h4 {
      font-size: 0.8em;
      text-transform: uppercase;
      font-weight: bold;     
    }
    body { margin:0;top:0;right:0;bottom:0;left:0;background-color:white;}
    .vega-bindings { visibility: hidden }
    .vega-actions { visibility: hidden }
    #chart-timeline {
      /*box-sizing: border-box;
      border: 1px solid blue;*/
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>

  <div id=title style="padding: 10px">
    <h1>Data Visualization Community's Geographical Trends</h1>
  </div>
  <div id='chart-timeline'></div>
  <script>
    const months = {
      0: 'Jan',
      1: 'Feb',
      2: 'Mar',
      3: 'Apr',
      4: 'May',
      5: 'Jun',
      6: 'Jul',
      7: 'Aug',
      8: 'Sep',
      9: 'Oct',
      10: 'Nov',
      11: 'Dec'
    }
    var colorPalette = {'iron': '#11210D', 'copper': '#773110', 'emerald': '#1E6E0F', 'navy': '#153252', 'plum': '#9f5f9c', 'mustard': '#dcb22a', 'turquoise': '#2db1a4', 'lightgrey': '#F3F3F3'}
    var axisColor = colorPalette.iron
    var axisPad = 6
    var parseDate = d3.timeParse("%b %Y");

    //////////////////// Set up and initiate containers ///////////////////////
    // MAIN TIMELINE
    var margin = {top: 20, right: 160, bottom: 80, left: 30}
    var rect = document.getElementById('chart-timeline').getBoundingClientRect()
    var w = rect.width * 0.85
    var h2 = rect.height
    var h2_chart = h2
    var timeline_svg = d3.select("#chart-timeline").append("svg")
      .attr("width", w + margin.left + margin.right)
      .attr("height", h2_chart + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .attr('pointer-events', 'all')

    var lines = timeline_svg.append('g').attr('class', 'lines')

    function init() {
      d3.queue()   
        .defer(d3.csv, './data/grouped_melt.csv') 
        .defer(d3.csv, './data/cleaned_survey_results_filtered.csv')
        .defer(d3.csv, './data/grouped_modes.csv') 
        .await(processData); 

    }
 
    function processData(error, csv, csv1, csv2) {

      data = csv.map((d,i) => {
        return {
          country: d.country,
          value: +d.value,
          date: parseDate(d.date)
        }
      })

      dataFull = csv1.map((d,i) => {
        return {
          country: d.country,
          level: d.level,
          role: d.role
        }
      })

      dataMode = csv2.map((d,i) => {
        return {
          country: d.country,
          mode: d.mode,
          value: d.values
        }
      })

      dataFull = dataFull.filter(d=>d.level != "")

      data = data.filter(d=>d.date > new Date(2000, 0, 1))

      // set up dropdown menu
      var countries = data.map(d=>d.country).filter(onlyUnique)
      menu(data, countries)
      multipleLineChart(data)

      // LEVELS
      var data_levels = nestData(dataFull, 'level', 'country')

      // ROLES
      var data_roles = nestData(dataFull, 'role', 'country')
      
      // MODES
      var modes1 = d3.nest()
        .key(d=>d['mode'])
        .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.value})} )
        .entries(dataMode)

      var modes = modes1.sort(function(a,b) { return b.value - a.value } ).map(d=>d.key)

      var dataMode_nested = d3.nest()
        .key(d=>d['mode'])
        .sortKeys(function(a,b) { return modes.indexOf(a) - modes.indexOf(b) } )
        .key(d=>d['country'])
        .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.value})} )
        .entries(dataMode)

      var data_modes = { data: dataMode_nested, sort_order: modes, max: d3.max(modes1, d=>d.value)}
      
    }

    function menu(data, countries) {

      countries.unshift("All Countries")
      d3.select(".dropdown-country .menu").selectAll("div")
          .data(countries)
        .enter().append("div")
          .attr('class', 'item')
          .attr("data-value", function (d) { return d })
          .text(function (d) { return d })
        .on("click", function(country) {
          if(country=='All Countries'){
          } else {
          }
        })

      }

    function nestData(data, X, Y) {

      var nested = d3.nest()
        .key(d=>d[X])
        .rollup(function(leaves) { return leaves.length })
        .entries(data)

      var sort_order = nested.sort(function(a,b) { return b.value - a.value } ).map(d=>d.key)
      var max = d3.max(nested, d=>d.value)

      var double_nested = d3.nest()
        .key(d=>d[X])
        .sortKeys(function(a,b) { return sort_order.indexOf(a) - sort_order.indexOf(b) } )
        .key(d=>d[Y])
        .rollup(function(leaves) { return leaves.length })
        .entries(data)

      return {data: double_nested, sort_order: sort_order, max: max}
    }

    function createLegend(category){

      d3.selectAll('.gLegend').selectAll('.legend-pill')
        .data(category)
        .enter().append('div')
          .attr("class", "legend-pill")
          .style("background-color", d=>color(d))
          .style("color", "white")
          .text(d=>d)

    }

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////// Stacked bar chart ///////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    function stackedBarChart(data) {

      var sectors = data.sort_order
      var max = data.max

      var dataNew = []
      data.data.map((D,I) => {
        var oneCountryBin = Array.from(Array(sort_order.length), () => 0)
        D.values.map((d,i) => {
          oneCountryBin[sort_order.indexOf(d.key)] = d.value
        })
        dataNew.push(oneCountryBin)
      })

      var stackedData = Object.assign(d3.stack().keys(d3.range(sort_order.length))(dataNew), {
        keys: sort_order,
        ids: sort_order.map(R => sectors.map(P => `${R}_${P}`)),
        sectors: sectors
      })

      var yScale = d3.scaleLinear()
          .domain([0, max])
          .range([h, 0])  

      var xScale = d3.scaleBand()
          .domain(sectors)
          .range([0, sectors.length <= 4 ? 300 : w])
          .padding(0.2)

      var countries_sorted = sort_order.slice(0,5)

      stackedData.forEach((d,i) => {
        stackedData.sectors.forEach((D,I) => {
          stackedData[i][I].key = stackedData.ids[i][I]
          stackedData[i][I].color = countries_sorted.indexOf(stackedData.keys[i])!=-1 ? color(stackedData.keys[i]) : colorPalette.lightgrey 
          stackedData[i][I].x = xScale(D)
          stackedData[i][I].y = ( d[I][1] ? yScale(d[I][1]) : yScale(0) ) 
          stackedData[i][I].width = xScale.bandwidth()
          stackedData[i][I].height = ( d[I][0] ? yScale(d[I][0]) : yScale(0) ) - ( d[I][1] ? yScale(d[I][1]) : yScale(0) )
        })
      })

      var groups = svg.selectAll("rect").data(stackedData.flat(), d=>d.key)

      groups.exit().remove()

      var groupsEnter = groups.enter().append("rect")

      groupsEnter
        .attr('class', d=>d.key)
        .attr("fill", d=>d.color)
        .attr("y", 0)
        .attr("width", 0)
        .attr("x", d => d.x)
        .attr("height", d => d.height)

      groups = groups.merge(groupsEnter)

      groups
        //.transition().duration(1000)
        .attr('class', d=>d.key)
        .attr("fill", d=>d.color)
        .attr("x", d => d.x)
        .attr("width", d => d.width)
        .attr("y", d => d.y)
        .attr("height", d => d.height)

      // AXES // 
      xAxis = d3.axisBottom(xScale).tickSizeOuter(0).tickSizeInner(-axisPad*2)
      yAxis = d3.axisLeft(yScale).tickSize(0)

      d3.select(".x_axis")
        //.transition().duration(1000)
        .call(xAxis)
        .call(g => {
          g.selectAll("text")
            .attr('fill', colorPalette.iron)
            .call(wrap, xScale.bandwidth());

          g.selectAll("line")
            .attr('stroke', colorPalette.iron)

          g.select(".domain").remove()

        })

      d3.select(".y_axis")
        //.transition().duration(1000)
        .call(yAxis)
        .call(g => {
          g.selectAll("text")
          .style("font-weight", "normal")
          .attr('fill', colorPalette.iron)
          .style("cursor", "pointer")

          g.selectAll("line")
            .attr('stroke', colorPalette.iron)
            .attr('stroke-width', 0.7) // make horizontal tick thinner and lighter so that line paths can stand out
            .attr('opacity', 0.3)

          g.select(".domain").remove()

         })
   
    }

    ///////////////////////////////////////////////////////////////////////////
    //////////////////////////// Multiple line chart //////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    function multipleLineChart(data) {

      var years = []
      d3.range(2000, 2020).map(year=>{
        Object.values(months).map(month=>{
          var label = month + ' ' + year.toString()
          years.push(parseDate(label))
        })
      })  

      var res_nested = d3.nest()
          .key(d=>d.country)
          .entries(data)

      var res_nested_sum = d3.nest()
        .key(d=>d.country)
        .rollup(function(leaves) { return d3.sum(leaves, d=>+d.value) })
        .entries(data)
        .sort(function(a, b){ return d3.descending(a.value, b.value) })
      
      sort_order = res_nested_sum.map(d=>d.key)
      var countries_sorted = sort_order.slice(0,5)

      res_nested = res_nested.sort(function(a,b) { return countries_sorted.indexOf(a.key) - countries_sorted.indexOf(b.key); })

      color = d3.scaleOrdinal()
        .domain(countries_sorted)
        .range([colorPalette.turquoise, colorPalette.mustard, colorPalette.plum, colorPalette.navy, colorPalette.copper, colorPalette.emerald])

      var xScale1 = d3.scaleTime()
        .domain(d3.extent(years, function(d) { return d }))
        .range([0, w])

      var yScale1 = d3.scaleSqrt()
        .domain([0, d3.max(res_nested.map(d=>d.values).flat(), d=>d.value)+50])
        .range([h2_chart, 0]);

      // APPEND MULTIPLE LINES //
      // line generator
      var line = d3.line() 
        .curve(d3.curveMonotoneX)
        .x(function(d) { return xScale1(d.date) })
        .y(function(d) { return yScale1(d.value) })

      // FOCUS
      var glines = lines.selectAll('path').data(res_nested)

      var entered_lines = glines.enter().append('path')

      glines.merge(entered_lines)  
        .attr('class', 'line')
        .attr('id', d=> 'line-' + d.key)
        .attr('d', function(d) { return line(d.values) })
        .attr('stroke', (d, i) => countries_sorted.indexOf(d.key)!=-1 ? color(d.key) : colorPalette.lightgrey)
        .attr('fill', 'none')
        .attr('opacity', 1)
        .attr('stroke-width', '15px')
        .style("mix-blend-mode", "multiply")

      glines.exit().remove()

      d3.selectAll('.line')
      .on("mouseover", function(el) {

        d3.selectAll('.line').attr('stroke', colorPalette.lightgrey)

        d3.select(this)
          .attr('cursor', 'pointer')
          .attr('stroke', countries_sorted.indexOf(el.key)!=-1 ? color(el.key) : colorPalette.emerald)
          .attr('stroke-width', '3px')
          .raise()

      })
      .on("mouseout", function(d,i) {

        d3.selectAll('.line')
          .attr('stroke', (d, i) => countries_sorted.indexOf(d.key)!=-1 ? color(d.key) : colorPalette.lightgrey)
          .attr('stroke-width', '3px') 

      })

    }

    init()

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////// Helper functions ////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    function onlyUnique(value, index, self) { 
        return self.indexOf(value) === index;
    }

    function sortOn(property) {
      return function(a, b){
        if(a[property] < b[property]){
            return -1;
        }else if(a[property] > b[property]){
            return 1;
        }else{
            return 0;   
        }
      }
    }

    function roundToNearest(x) {
      return Math.round(x / 100) * 100
    }

    function wrap(text, width) {
      text.each(function() {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 0,
            lineHeight = 1.1, // ems
            y = text.attr("y"),
            dy = parseFloat(text.attr("dy")),
            tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
          }
        }
      });
    }

  </script>
</body>
</html>