<!DOCTYPE html> 

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Styling -->
  <link rel="stylesheet" type="text/css" href="../vendor/semantic/semantic.min.css">
  <link rel="stylesheet" type="text/css" href="../vendor/semantic/semantic-ui-range.css">

  <!-- JavaScript files -->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.3.4/chroma.min.js"></script>
  <script
    src="https://code.jquery.com/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
    crossorigin="anonymous"></script>
  <script src="../vendor/semantic/semantic.min.js"></script>
  <script src="../vendor/semantic/semantic-ui-range.js"></script>
  <style>
    .axis path, .axis tick, .axis line {
      fill: none;
      stroke: none;
    }
  </style>
</head>
<body>

  <div id="wrapper">
    <div id="container">
      <div id="chart"></div>

      <div id="vis-nav">
        <a href="#" id="step-1" class="step-link active target">Step1</a>
        <a href="#" id="step-2" class="step-link">Step2</a>
        <a href="#" id="step-3" class="step-link">Step3</a>
      </div>
  
    </div>
  </div>

  <script>
    
    var main = function () {

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////// Globals /////////////////////////////////
      /////////////////////////////////////////////////////////////////////////// 
      var colorScale, countScale, xScale, yScale, rScale, svg, groups, countries
      const margin = { top: 50, right: 0, bottom: 0, left: 100 },
          width = window.innerWidth*0.98 - margin.left - margin.right,
          height = window.innerHeight*0.58 - margin.top - margin.bottom,
          gridSize = 24

      ///////////////////////////////////////////////////////////////////////////
      ///////////////////////////////// Initialize //////////////////////////////
      /////////////////////////////////////////////////////////////////////////// 

      return { 
        run : function () {

          loadData()

          ///////////////////////////////////////////////////////////////////////////
          ////////////////////////////// Generate data //////////////////////////////
          ///////////////////////////////////////////////////////////////////////////

          function loadData() {

            d3.queue()   // queue function loads all external data files asynchronously 
              .defer(d3.csv, './data/donor_ratio_m.csv')  
              .await(processData);   

          }

          function processData(error, data) {
            
            if (error) throw error;

            data.forEach(d=>{
              d.x = d.country
              d.y = d.group
              d.value = +d.value
              d.r = +d.total
            })
            drawHeatMap(data)
            createGradient([-1,1], '')

            var steps = {
              "step-1": function(){ 
                data.forEach(d=>{
                  d.x = d.country
                  d.y = d.group
                  d.value = +d.value
                  d.r = +d.total
                })
                updateHeatMap(data, [-1, 0, 1])
                svg.select('defs').remove()
                d3.select('.legendWrapper').remove()
                createGradient([-1,1], '')
              },
              "step-2": function(){ 
                data.forEach(d=>{
                  d.x = d.country
                  d.y = d.group
                  d.value = +d['donor_growth']
                  d.r = +d.total
                })
                updateHeatMap(data, [-5, 0, 25])
                svg.select('defs').remove()
                d3.select('.legendWrapper').remove()
                createGradient([-5,25], 'Donor Growth Percentage (%)')
              },
              "step-3": function(){ 
                data.forEach(d=>{
                  d.x = d.country
                  d.y = d.group
                  d.value = +d['recipient_growth']
                  d.r = +d.total
                })
                updateHeatMap(data, [-5, 0, 25])
                svg.select('defs').remove()
                d3.select('.legendWrapper').remove()
                createGradient([-5,25], 'Recipient Growth Percentage (%)')
              },
            }

            function switchStep(newStep){
              d3.selectAll(".step-link").classed("active", false);
              d3.select("#" + newStep).classed("active", true);
              
              var action = steps[newStep]
              action();
            }
            
            function nextStep(){
              var attrID = d3.select(".active").attr("id").split("-")[0]
                  activeIndex = +d3.select(".active").attr("id").split("-")[1],
                  targetIndex = +d3.select(".target").attr("id").split("-")[1],
                  nextIndex = activeIndex + Math.sign(targetIndex - activeIndex);
              
              return (nextIndex == activeIndex) ? false : [attrID, nextIndex].join("-");
            }
            
            function switchTarget(newStep){
              d3.selectAll(".step-link").classed("target", false);
              d3.select("#" + newStep).classed("target", true);
            }

            d3.selectAll("a.step-link").on("click", function(d){
              var clickedStep = d3.select(this).attr("id");
              switchTarget(clickedStep);
              switchStep(nextStep());
              
              return false;
            });
            
          }

          ///////////////////////////////////////////////////////////////////////////
          //////////////////////////////// GEOGRAPHIC MAP ///////////////////////////
          ///////////////////////////////////////////////////////////////////////////
          function drawGeographicMap(data) {

          }

          ///////////////////////////////////////////////////////////////////////////
          /////////////////////////////////// HEAT MAP //////////////////////////////
          ///////////////////////////////////////////////////////////////////////////
          function drawHeatMap(data) {

            groups = data.map(d=>d.group).filter(onlyUnique)
            countries = data.map(d=>d.country).filter(onlyUnique)

            xScale = d3.scaleBand()
              .domain(countries)
              .range([0, (countries.length * gridSize)])

            yScale = d3.scaleBand()
              .domain(groups)
              .range([0, (groups.length * gridSize)])

            rScale = d3.scaleSqrt()
              .domain(d3.extent(data, d=>d.total))
              .range([0, 8])

            svg = d3.select("#chart").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var xAxis = d3.axisBottom(xScale)
              .tickSize(0)
              .tickValues(xScale.domain())

            const xaxis = svg.append('g')
              .attr('class', 'x_axis')
              .attr("transform", "translate(" + 0 + "," + (groups.length * gridSize) + ")")
              .call(xAxis)
              .call(g => {
                g.selectAll("text")
                  .style("text-anchor", "start")
                  .attr("transform", d=> `translate(${-xScale.bandwidth()/2}, 0)rotate(50)`) 
                  .attr('fill', 'black')
                g.select(".domain").remove()
              })    

            const yaxis = svg.append('g')
              .attr('class', 'y_axis')
              .attr("transform", "translate(" + 0 + "," + yScale.bandwidth()/2 + ")")

            const dayLabels = yaxis.selectAll(".dayLabel")
                .data(groups)
                .enter().append("text")
                  .attr('class', 'dayLabel')
                  .text(function (d) { return d; })
                  .attr("x", -15)
                  .attr("y", (d, i) => (i * gridSize))
                  .attr('fill', 'black')
                  .style("text-anchor", "end")

            updateHeatMap(data, [-1, 0, 1])

          }

          function updateHeatMap(data, RANGE) {
       
            colorScale = d3.scaleLinear()
              .domain(RANGE)
              .range(['#FDB715', '#E3E5E5', '#70CACB']);

            const cards = svg.selectAll(".hour").data(data, (d) => d.index);

            cards.append("title");

            cards.enter().append("circle")
                .attr("cx", function(d) { return xScale(d.x) })
                .attr("cy", function(d) { return yScale(d.y) })
                .attr("r", function(d) { return 10 })
                //.attr("r", function(d) { return rScale(d.r) })
                .attr("class", "hour bordered")
                .attr("width", gridSize)
                .attr("height", gridSize)
                .style("fill", function(d) { 
                  console.log(colorScale(d.value), d.value)
                  return colorScale(d.value) })
              .merge(cards)
                .transition()
                .duration(1000)
                .style("fill", (d) => colorScale(d.value))

            cards.select("title").text((d) => d.value);

            cards.exit().remove();

          }

          ///////////////////////////////////////////////////////////////////////////
          //////////////// Create the gradient for the legend ///////////////////////
          ///////////////////////////////////////////////////////////////////////////
          function createGradient(RANGE, TEXT) {

            const countScale = d3.scaleLinear() //Extra scale since the color scale is interpolated
              .domain(RANGE)
              .range([0, width])

            //Calculate the variables for the temp gradient
            var numStops = 10;
            countRange = countScale.domain();
            countRange[2] = countRange[1] - countRange[0];
            countPoint = [];
            for(var i = 0; i < numStops; i++) {
              countPoint.push(i * countRange[2]/(numStops-1) + countRange[0]);
            }//for i

            //Create the gradient
            svg.append("defs")
              .append("linearGradient")
              .attr("id", "legend-traffic")
              .attr("x1", "0%").attr("y1", "0%")
              .attr("x2", "100%").attr("y2", "0%")
              .selectAll("stop") 
              .data(d3.range(numStops))                
              .enter().append("stop") 
              .attr("offset", function(d,i) { 
                return countScale( countPoint[i] )/width;
              })   
              .attr("stop-color", function(d,i) { 
                return colorScale( countPoint[i] ); 
              });

            drawLegend(RANGE, TEXT)
          }

          ///////////////////////////////////////////////////////////////////////////
          ////////////////////////// Draw the legend ////////////////////////////////
          ///////////////////////////////////////////////////////////////////////////
          function drawLegend(RANGE, TEXT) {

            var legendWidth = Math.min(width*0.8, 400);
            //Color Legend container
            var legendsvg = svg.append("g")
              .attr("class", "legendWrapper")
              .attr("transform", "translate(" + (gridSize * countries.length)/2 + "," + (gridSize * groups.length + 120) + ")");

            //Draw the Rectangle
            legendsvg.append("rect")
              .attr("class", "legendRect")
              .attr("x", -legendWidth/2)
              .attr("y", 0)
              //.attr("rx", hexRadius*1.25/2)
              .attr("width", legendWidth)
              .attr("height", 10)
              .style("fill", "url(#legend-traffic)");
              
            //Append title
            legendsvg.append("text")
              .attr("class", "legendTitle")
              .attr("x", 0)
              .attr("y", -10)
              .style("text-anchor", "middle")
              .text(TEXT);

            //Set scale for x-axis
            var xScale = d3.scaleLinear()
               .range([-legendWidth/2, legendWidth/2])
               .domain(RANGE);

            //Define x-axis
            var xAxis = d3.axisBottom()
                .ticks(5)
                //.tickFormat(formatPercent)
                .scale(xScale);

            //Set up X axis
            legendsvg.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(0," + (10) + ")")
              .call(xAxis);

          }

        } 
      }

    }()

    main.run()

  function onlyUnique(value, index, self) { 
      return self.indexOf(value) === index;
  }
  </script>
</body>
</html>